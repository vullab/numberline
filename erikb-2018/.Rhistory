p1.display <- paste("<b>","Player1",br(),
sub.data$player1_move,br(),
round(as.numeric(sub.data$player1_rt)),br(),
sub.data$player1_total,br(),
player1_win,"/",numround,"(",player1_wpct,")",br(),
player2_win,"/",numround,"(",player2_wpct,")",br(),
player_tie,"/",numround,"(",tie_pct,")")
HTML(p1.display)
})
#replay tabpanel: PLAYER2
output$text3 <- renderUI({
#user input
if(is.null(data())){return ()}
numround = input$round
#output for certain round
sub.data <- subset(data(),round_index==numround)
#result display (text part)
p2.display <- paste("<b>","Player2",br(),
sub.data$player2_move,br(),
round(as.numeric(sub.data$player2_rt)),br(),
sub.data$player2_total,br(),
player2_win,"/",numround,"(",player2_wpct,")",br(),
player1_win,"/",numround,"(",player1_wpct,")",br(),
player_tie,"/",numround,"(",tie_pct,")")
HTML(p2.display)
})
#set action buttons
observeEvent(input$prevbutton, {
total.row <- nrow(data())
num_round <- seq(1, total.row, by = 1)
current <- which(num_round == input$round)
if(current > 1){
updateSelectInput(session, "round",
choices = as.list(num_round),
selected = num_round[current - 1])
}
})#end of previous button
observeEvent(input$nextbutton, {
total.row <- nrow(data())
num_round <- seq(1, total.row, by = 1)
current <- which(num_round == input$round)
if(current < length(num_round)){
updateSelectInput(session, "round",
choices = as.list(num_round),
selected = num_round[current + 1])
}
})#end of next button
observeEvent(input$end, {
total.row <- nrow(data())
num_round <- seq(1, total.row, by = 1)
updateSelectInput(session, "round",
choices = as.list(num_round),
selected = num_round[total.row])
})#end of ending button
observeEvent(input$start, {
total.row <- nrow(data())
num_round <- seq(1, total.row, by = 1)
updateSelectInput(session, "round",
choices = as.list(num_round),
selected = num_round[1])
})#end of starting button
#plot display
output$plot1 <- renderPlot({
bar1 <- ggplot(data = data(), aes(x = player1_outcome)) +
geom_bar(aes(y = (..count..)/sum(..count..)*100),fill = "lightskyblue3")+
labs(x = "Player1 Outcome",y = "Percent")+
geom_hline(linetype="dashed",color="red",yintercept=33)
bar1.1 <- ggplot(data = data(), aes(x = player1_move)) +
geom_bar(aes(y = (..count..)/sum(..count..)*100),fill = "lightskyblue3")+
labs(x = "Player1 Move",y = "Percent")+
geom_hline(linetype="dashed",color="red",yintercept=33)
grid.arrange(bar1,bar1.1,ncol=1)
})
output$plot2 <- renderPlot({
bar2 <- ggplot(data = data(), aes(x = player2_outcome)) +
geom_bar(aes(y = (..count..)/sum(..count..)*100))+
labs(x = "Player2 Outcome",y = "Percent")+
geom_hline(linetype="dashed",color="red",yintercept=33)
bar2.1 <- ggplot(data = data(), aes(x = player2_move)) +
geom_bar(aes(y = (..count..)/sum(..count..)*100))+
labs(x = "Player2 Move",y = "Percent")+
geom_hline(linetype="dashed",color="red",yintercept=33)
grid.arrange(bar2,bar2.1, ncol=1)
}) # end of bar chart plot
#transition matrix output
output$matrix1 <- renderTable(rownames = TRUE,{
if(nrow(data())<=1){}
else{transition(data()$player1_move)}
})
output$matrix2 <- renderTable(rownames = TRUE,{
if(nrow(data())<=1){}
else{transition(data()$player2_move)}
})
output$matrix3 <- renderTable(rownames = TRUE,{
if(nrow(data())<=1){}
else{transition_o(data()$player1_outcome,data()$player1_move)}
})
output$matrix4 <- renderTable(rownames = TRUE,{
if(nrow(data())<=1){}
else{transition_o(data()$player2_outcome,data()$player2_move)}
})#end of transition matrix output
#title for summary tabpanel
output$title1 <- renderUI({
title <- paste(br(),"PLAYER1",br(),br())
HTML(title)
})
output$title2 <- renderText({
title <- paste(br(),"PLAYER2",br(),br())
HTML(title)
})#end of title of summary part
#helper method for calculating move transition matrix
transition <- function(data){
t_matrix <- matrix(0, nrow = 4, ncol = 4)
names <- c("no_choice","rock","paper","scissors")
rownames(t_matrix) <- c('N/A','R','P','S')
colnames(t_matrix) <- c('N/A','R','P','S')
current <- which(names == data[1])
for (i in data[-1]){
if (i == "rock"){
t_matrix[current,2] <- t_matrix[current,2]+1
current <- 2
}
else if (i == "paper"){
t_matrix[current,3] <- t_matrix[current,3]+1
current <- 3
}
else if (i == "scissors"){
t_matrix[current,4] <- t_matrix[current,4]+1
current <- 4
}
else{
t_matrix[current,1] <- t_matrix[current,1]+1
current <- 1
}
}
result <- t_matrix/rowSums(t_matrix)
result[is.nan(result)] <- 0
result
}#end of helper method 1
#helper method for calculating outcome transition matrix
transition_o <- function(list_a,list_b){
t_matrix <- matrix(0, nrow = 3, ncol = 4)
colnames(t_matrix) <- c('same','forward','reverse','N/A')
rownames(t_matrix) <- c('win','loss','tie')
current <- -1
for (i in seq(1,length(list_a)-1)){
if (list_b[i]=="no_choice"){
next
}
if(list_a[i]=="win"){
current<-direction(list_b[i],list_b[i+1])
t_matrix[1,current] <- t_matrix[1,current]+1
}
else if (list_a[i]=="loss"){
current<-direction(list_b[i],list_b[i+1])
t_matrix[2,current] <- t_matrix[2,current]+1
}
else{
current<-direction(list_b[i],list_b[i+1])
t_matrix[3,current] <- t_matrix[3,current]+1
}
}
result <- t_matrix/rowSums(t_matrix)
result[is.nan(result)] <- 0
result
}#end of helper method2
#helper method for tracking direction
direction<-function(o1,o2){
dir <- c("rock","paper","scissors","rock")
if(o1==o2){
return <- 1
}
else if(o2=="no_choice"){
return <- 4
}
else{
if(dir[which(dir==o1)[1]+1]==o2){
return <- 2
}
else{
return <-3
}
}
} #end of helper method for tracking direction
}#end of server
}
shinyApp(ui, server)
runApp('~/web/vullab/RPS_Data/data_display.R')
setwd("/Users/erikbrockbank/web/vullab/numberline/erikb-2018/")
rm(list=ls())
library(viridis)
# Fetch relevant model functions from samples_model
source('samples_model-fxns_basic.R')
# Fetch relevant functions for fitting lines to model data
source('samples_model-fxns_drift.R')
get.split.half.cor = function(data) {
data = data %>%
group_by(subject) %>%
# mutate(split.half = as.numeric(trial %% 2 == 0)) %>% # this is just a stand-in, we shuffle these below
# mutate(split.half = replace(split.half, values = sample(split.half, length(split.half), replace = F)))
mutate(split.half = trial <= max(data$trial) / 2)
# Fit subject split half estimates
d0 = data %>%
filter(split.half == 0)
d1 = data %>%
filter(split.half == 1)
split.half.fits.0 = data.frame(do.call(rbind, by(d0, d0$subject, brutefit)))
print(paste("Failed split half fits:", sum(split.half.fits.0$logL == -9999)))
split.half.fits.1 = data.frame(do.call(rbind, by(d1, d1$subject, brutefit)))
print(paste("Failed split half fits:", sum(split.half.fits.1$logL == -9999)))
split.half.corrs = cor.test(split.half.fits.0$b, split.half.fits.1$b)
return(split.half.corrs)
}
# Graphing functions
my.log.breaks = function(lims){
majors = seq(floor(log10(lims[1])), ceiling(log10(lims[2])), by = 1)
minors = log10(unlist(lapply(majors[-1], function(x){seq(10 ^ (x - 1), 9 * 10 ^ (x - 1), by = 10 ^ (x - 1))})))
return(list(majors, minors))
}
mylogx = function(lims){
breaks = my.log.breaks(lims)
scale_x_log10(limits = lims,
breaks = 10 ^ breaks[[1]],
minor_breaks = breaks[[2]])
}
mylogy = function(lims){
breaks = my.log.breaks(lims)
scale_y_log10(limits = lims,
breaks = 10 ^ breaks[[1]],
minor_breaks = breaks[[2]])
}
individ_plot_theme = theme(
# titles
plot.title = element_text(face = "bold", size = 28),
axis.title.y = element_text(face = "bold", size = 24),
axis.title.x = element_text(face = "bold", size = 24),
legend.title = element_text(face = "bold", size = 16),
# axis text
axis.text.y = element_text(size = 14),
axis.text.x = element_text(size = 14, angle = 90, hjust = 0, vjust = 0),
# legend text
legend.text = element_text(size = 14),
# facet text
strip.text = element_text(face = "bold", size = 20),
# backgrounds, lines
panel.background = element_blank(),
strip.background = element_blank(),
panel.grid = element_line(color = "gray"),
axis.line = element_line(color = "black"),
# positioning
legend.position = "bottom"
)
plot.estimates.all = function(data, graph.title) {
data %>%
ggplot(aes(x = num_dots, y = answer)) +
geom_point(alpha = 0.25, color = "red", size = 0.75) +
geom_abline() +
mylogx(c(MIN_ESTIMATE, MAX_ESTIMATE)) +
mylogy(c(MIN_ESTIMATE, MAX_ESTIMATE + 200)) +
xlab("Number presented") +
ylab("Number reported") +
ggtitle(graph.title) +
theme(axis.title = element_text(size = 16, face = "bold"),
title = element_text(size = 18, face = "bold")) +
facet_wrap(~subject, ncol = 6)
}
plot.model.comparison.histogram = function(model.slopes.low, model.slopes.high, subj.slopes) {
ggplot() +
# subject slopes
geom_histogram(data = model.slopes.low, aes(x = slope.trans, color = "model.low", fill = "model.low"),
alpha = 0.5,
binwidth = 0.05) +
# high var slopes
geom_histogram(data = model.slopes.high, aes(x = slope.trans, color = "model.high", fill = "model.high"),
alpha = 0.5,
binwidth = 0.05) +
geom_vline(xintercept = mean(subj.slopes$slope.trans), color = "black", linetype = "dashed", size = 2) +
scale_color_manual(name = element_blank(),
labels = c("model.low" = "low variability model",
"model.high" = "high variability model"),
values = c("model.low" = "red", "model.high" = "blue")) +
scale_fill_manual(name = element_blank(),
labels = c("model.low" = "low variability model",
"model.high" = "high variability model"),
values = c("model.low" = "red", "model.high" = "blue")) +
# scale_color_viridis(name = element_blank(),
#                    labels = c("model.low" = "low variability model",
#                               "model.high" = "high variability model"),
#                    discrete = T,
#                    begin = 0, end = 0.5) +
# scale_fill_viridis(name = element_blank(),
#                   labels = c("model.low" = "low variability model",
#                              "model.high" = "high variability model"),
#                   discrete = T,
#                   begin = 0, end = 0.5) +
ggtitle("Comparing model slope variability") +
labs(x = "Fitted bilinear slope") +
individ_plot_theme
}
plot.model.human.comparison.histogram = function(model.slopes, subj.slopes, plot.title) {
ggplot() +
# subject slopes
geom_histogram(data = subj.slopes, aes(x = slope.trans, color = "subjects", fill = "subjects"),
alpha = 0.5,
binwidth = 0.05) +
# high var slopes
geom_histogram(data = model.slopes, aes(x = slope.trans, color = "model", fill = "model"),
alpha = 0.5,
binwidth = 0.05) +
scale_color_manual(name = element_blank(),
labels = c("subjects" = "subjects",
"model" = "model"),
values = c("subjects" = "red", "model" = "blue")) +
scale_fill_manual(name = element_blank(),
labels = c("subjects" = "subjects",
"model" = "model"),
values = c("subjects" = "red", "model" = "blue")) +
ggtitle(plot.title) +
labs(x = "Fitted bilinear slope") +
individ_plot_theme
}
plot.model.comparison.scatter = function(model.slopes.low, model.slopes.high, subj.slopes) {
ggplot() +
geom_point(data = model.slopes.low, aes(x = cutoff.trans, y = slope.trans, color = "model.low"),
size = 3) +
geom_errorbar(data = model.slopes.low, aes(x = cutoff.trans,
ymin = slope.trans - slope.error.trans,
ymax = slope.trans + slope.error.trans,
color = "model.low"),
width = 0) +
geom_point(data = model.slopes.high, aes(x = cutoff.trans, y = slope.trans, color = "model.high"),
size = 3) +
geom_errorbar(data = model.slopes.high, aes(x = cutoff.trans,
ymin = slope.trans - slope.error.trans,
ymax = slope.trans + slope.error.trans,
color = "model.high"),
width = 0) +
geom_hline(yintercept = 1.0, linetype = "dashed") +
scale_color_manual(name = "Data source",
values = c("model.low" = "red", "model.high" = "blue"),
labels = c("model.low" = "low variability model", "model.high" = "high variability model")) +
# ylim(0, 1.5) +
# xlim(0, 30) +
ggtitle("Comparing model fits") +
labs(x = "Fitted bilinear cutoff", y = "Fitted slope above cutoff") +
individ_plot_theme
}
plot.model.human.comparison.scatter = function(model.slopes, subj.slopes, plot.title) {
ggplot() +
geom_point(data = subj.slopes, aes(x = cutoff.trans, y = slope.trans, color = "subjects"),
size = 3) +
geom_errorbar(data = subj.slopes, aes(x = cutoff.trans, color = "subjects",
ymin = slope.trans - slope.error.trans,
ymax = slope.trans + slope.error.trans),
width = 0) +
geom_point(data = model.slopes, aes(x = cutoff.trans, y = slope.trans, color = "model"),
size = 3) +
geom_errorbar(data = model.slopes, aes(x = cutoff.trans,
ymin = slope.trans - slope.error.trans,
ymax = slope.trans + slope.error.trans,
color = "model"),
width = 0) +
geom_hline(yintercept = 1.0, linetype = "dashed") +
scale_color_manual(name = "Data source",
values = c("subjects" = "red", "model" = "blue"),
labels = c("subjects" = "subjects", "model" = "model")) +
ylim(0, 1.5) +
xlim(0, 30) +
ggtitle(plot.title) +
labs(x = "Fitted bilinear cutoff", y = "Fitted slope above cutoff") +
individ_plot_theme
}
plot.model.human.split.half = function(split.half.corrs) {
split.half.corrs %>%
ggplot(aes(x = fct_reorder(source, mean.corr, .desc = TRUE), y = mean.corr, fill = source)) +
geom_bar(stat = "identity", width = 0.5) +
geom_errorbar(aes(ymin = lower.corr, ymax = upper.corr), width = 0.25) +
labs(x = "", y = "Fitted slope correlation") +
ggtitle("Split half model comparison") +
individ_plot_theme +
scale_fill_viridis(discrete = T) +
theme(axis.text.x = element_blank(),
legend.title = element_blank())
}
PARAMS = c(0.7, 1.5, -0.5, 0.2, -0.7, 0.2)
names(PARAMS) = c("ma", "sa", "mb", "sb", "ms", "ss")
PRIORS = list()
PRIORS[[1]] = function(x){-dnorm(x, 1.5, 0.1, log = T)} #
PRIORS[[2]] = function(x){-dnorm(x, -0.2, 0.1, log = T)} #
PRIORS[[3]] = function(x){-dnorm(x, -1, 0.1, log = T)} #
MODEL_RUNS = 10 # NB: takes about 90s per model run
subj.data = run.model.baseline()
subj.data = subj.data %>%
select(subject, trial, num_dots, answer)
model.data.high.var = model.wrapper(nruns = 1,
model.fxn = run.model.individ.memories,
n.memories = 10)
model.data.low.var = model.wrapper(nruns = 1,
model.fxn = run.model.individ.memories,
n.memories = 1000)
# Fit cutoff, slope params
bipower.fits.subj = data.frame(do.call(rbind, by(subj.data, subj.data$subject, brutefit)))
bipower.fits.mod.high = data.frame(do.call(rbind, by(model.data.high.var, model.data.high.var$subject, brutefit)))
bipower.fits.mod.low = data.frame(do.call(rbind, by(model.data.low.var, model.data.low.var$subject, brutefit)))
# Add columns transforming fits to non-log space
bipower.fits.subj = bipower.fits.subj %>%
mutate(cutoff.trans = 10^a,
slope.trans = 10^b)
bipower.fits.mod.high = bipower.fits.mod.high %>%
mutate(cutoff.trans = 10^a,
slope.trans = 10^b)
bipower.fits.mod.low = bipower.fits.mod.low %>%
mutate(cutoff.trans = 10^a,
slope.trans = 10^b)
# Histogram of model fits compared against each other
plot.model.comparison.histogram(bipower.fits.mod.low, bipower.fits.mod.high, bipower.fits.subj)
# Overall structure for storing correlation values
split.half.corrs = data.frame(source = character(),
model.run = numeric(),
corr = numeric(),
lower.ci = numeric(),
upper.ci = numeric())
for (x in seq(1:MODEL_RUNS)) {
print(paste("######## CYCLE: ", x, " ########"))
# Run models
subj.data = run.model.baseline()
subj.data = subj.data %>%
select(subject, trial, num_dots, answer)
model.data.high.var = model.wrapper(nruns = 1,
model.fxn = run.model.individ.memories,
n.memories = 10)
model.data.low.var = model.wrapper(nruns = 1,
model.fxn = run.model.individ.memories,
n.memories = 1000)
model.data.baseline = model.wrapper(nruns = 1,
model.fxn = run.model.baseline)
# Get split half correlations
subj.cors = get.split.half.cor(subj.data)
model.data.high.var.cors = get.split.half.cor(model.data.high.var)
model.data.low.var.cors = get.split.half.cor(model.data.low.var)
model.baseline.cors = get.split.half.cor(model.data.baseline)
# Update aggregate data frame of split half corrs
split.half.corrs = rbind(split.half.corrs, data.frame(source = "subjects",
model.run = x,
corr = subj.cors$estimate,
lower.ci = subj.cors$conf.int[1],
upper.ci = subj.cors$conf.int[2]))
split.half.corrs = rbind(split.half.corrs, data.frame(source = "model.high.var",
model.run = x,
corr = model.data.high.var.cors$estimate,
lower.ci = model.data.high.var.cors$conf.int[1],
upper.ci = model.data.high.var.cors$conf.int[2]))
split.half.corrs = rbind(split.half.corrs, data.frame(source = "model.low.var",
model.run = x,
corr = model.data.low.var.cors$estimate,
lower.ci = model.data.low.var.cors$conf.int[1],
upper.ci = model.data.low.var.cors$conf.int[2]))
split.half.corrs = rbind(split.half.corrs, data.frame(source = "model.baseline",
model.run = x,
corr = model.baseline.cors$estimate,
lower.ci = model.baseline.cors$conf.int[1],
upper.ci = model.baseline.cors$conf.int[2]))
}
# Summarize many model runs above
split.half.summary = split.half.corrs %>%
group_by(source) %>%
summarize(mean.corr = mean(corr),
n.obs = n(),
corr.sd = sd(corr),
corr.se = sd(corr) / sqrt(n.obs),
lower.corr = mean.corr - corr.se,
upper.corr = mean.corr + corr.se)
# Bar plot of correlations over multiple runs above
plot.model.human.split.half(split.half.summary)
plot.model.human.split.half = function(split.half.corrs) {
split.half.corrs %>%
ggplot(aes(x = fct_reorder(source, mean.corr, .desc = TRUE), y = mean.corr, fill = source)) +
geom_bar(stat = "identity", width = 0.5) +
geom_errorbar(aes(ymin = lower.corr, ymax = upper.corr), width = 0.25) +
labs(x = "", y = "Fitted slope correlation") +
ggtitle("Split half model comparison") +
individ_plot_theme +
scale_fill_viridis(discrete = T,
labels = c("subjects" = "subjects",
"model.high.var" = "High variability model",
"model.low.var" = "Low variability model",
"model.baseline" = "Baseline model")) +
theme(axis.text.x = element_blank(),
legend.title = element_blank())
}
# Bar plot of correlations over multiple runs above
plot.model.human.split.half(split.half.summary)
# Save data
save(split.half.corrs, split.half.summary, bipower.fits.mod.low, bipower.fits.mod.high, bipower.fits.subj, file="samples_model_individual_var.RData")
plot.model.human.split.half = function(split.half.corrs) {
split.half.corrs %>%
ggplot(aes(x = fct_reorder(source, mean.corr, .desc = TRUE), y = mean.corr, fill = source)) +
geom_bar(stat = "identity", width = 0.5) +
geom_errorbar(aes(ymin = lower.corr, ymax = upper.corr), width = 0.25) +
labs(x = "", y = "Fitted slope correlation") +
ggtitle("Split half model comparison") +
individ_plot_theme +
scale_fill_viridis(discrete = T,
labels = c("subjects" = "subjects",
"model.high.var" = "high variability model",
"model.low.var" = "low variability model",
"model.baseline" = "baseline model")) +
theme(axis.text.x = element_blank(),
legend.title = element_blank())
}
# Bar plot of correlations over multiple runs above
plot.model.human.split.half(split.half.summary)
